#!/usr/bin/env python3

import sys
import rclpy
from rclpy.action import ActionClient
from rclpy.node import Node
from builtin_interfaces.msg import Duration
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
from control_msgs.action import FollowJointTrajectory
from itertools import zip_longest

# Helper function to send a goal and return the result future (non-blocking)
def start_trajectory(node, client, joint_names, positions):
    if positions is None:
        return None

    traj = JointTrajectory()
    traj.joint_names = joint_names
    point = JointTrajectoryPoint()
    point.positions = positions
    point.time_from_start = Duration(sec=30)
    traj.points.append(point)

    goal_msg = FollowJointTrajectory.Goal()
    goal_msg.trajectory = traj

    # Send goal
    print(f"Sending goal to {client._action_name}...")
    send_goal_future = client.send_goal_async(goal_msg)

    # Wait strictly for the server to ACCEPT the goal (fast)
    rclpy.spin_until_future_complete(node, send_goal_future)
    goal_handle = send_goal_future.result()

    if not goal_handle.accepted:
        print(f"Goal rejected for {client._action_name}")
        return None

    # Return the future that tracks the actual execution (slow)
    return goal_handle.get_result_async()

def main():
    rclpy.init()
    node = rclpy.create_node('simple_arm_mover')

    # 1. Setup Data
    canadarm2_joints = [
        "joint_canadarm2_1", "joint_canadarm2_2", "joint_canadarm2_3",
        "joint_canadarm2_4", "joint_canadarm2_5", "joint_canadarm2_6",
        "joint_canadarm2_7"
    ]
    mbs_joints = ["joint_mbs"]

    canadarm2_poses = [
        [0.51, 1.48, -0.677, 0.534, -0.062, -0.645, -0.755],
        [0.0, 0.628, -0.187, 0.0, 0.0, 0.0, 0.0]
    ]
    mbs_poses = [
        [0.0],
        [8.0],
        [-4.0]
    ]

    # 2. Setup Clients
    arm_client = ActionClient(
        node, FollowJointTrajectory,
        '/canadarm2_joint_trajectory_controller/follow_joint_trajectory'
    )
    mbs_client = ActionClient(
        node, FollowJointTrajectory,
        '/mobile_base_system_joint_trajectory_controller/follow_joint_trajectory'
    )

    print("Waiting for action servers...")
    arm_client.wait_for_server()
    mbs_client.wait_for_server()
    print("Servers ready.")

    # 3. Iterate through poses (zipping ensures we handle different list lengths)
    # zip_longest allows the shorter list to return 'None' while the longer continues
    for i, (arm_pos, mbs_pos) in enumerate(zip_longest(canadarm2_poses, mbs_poses)):

        print(f"\n--- Starting Pose Set {i} ---")

        # Start both movements concurrently
        future_arm = start_trajectory(node, arm_client, canadarm2_joints, arm_pos)
        future_mbs = start_trajectory(node, mbs_client, mbs_joints, mbs_pos)

        # Wait until BOTH are done
        while (future_arm and not future_arm.done()) or (future_mbs and not future_mbs.done()):
            rclpy.spin_once(node, timeout_sec=0.1)

        print(f"Pose Set {i} complete.")

    # 4. Cleanup and Exit
    print("\nAll poses finished. Exiting.")
    node.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()